/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include "DSFunc.h"

// Global Variables.
int n, choice, *Y;
float *temp, a, *result_1;
max_min *result_2;
aY *result_3;

void
concurrent_ser_prog_1(char *host)
{
	CLIENT *clnt;
	Y_arr  average_1_arg;
	Y_arr  maxmin_1_arg;
	a_mul_Y  product_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, CONCURRENT_SER_PROG, CONCURRENT_SER_VER, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	if(choice==1){
	
		average_1_arg.Y.Y_len=n;
		average_1_arg.Y_size=n;
		average_1_arg.Y.Y_val=(int *) malloc(n*sizeof(int));
	
		for(int i=0;i<n;i++){
		// Matching the variables.
			average_1_arg.Y.Y_val[i]=Y[i];	
		}
	
		result_1 = average_1(&average_1_arg, clnt);
		if (result_1 == (float *) NULL) {
			clnt_perror (clnt, "call failed");
			}
	}
	else if (choice==2){
	// Matching variables.
		maxmin_1_arg.Y.Y_len=n;
		maxmin_1_arg.Y_size=n;
		maxmin_1_arg.Y.Y_val=(int *)malloc(n*sizeof(int));
		for(int i=0;i<n;i++){
			maxmin_1_arg.Y.Y_val[i]= Y[i];
		}
	
		result_2 = maxmin_1(&maxmin_1_arg, clnt);
		if (result_2 == (max_min *) NULL) {
			clnt_perror (clnt, "call failed");
		}
	
	}
	else if (choice==3){
	// Matching variables once again for a*Y[].
		product_1_arg.Y.Y_len=n;
		product_1_arg.Y_size=n;
		product_1_arg.Y.Y_val=(int *) malloc(n*sizeof(int));
		
		for(int i=0;i<n;i++){
			product_1_arg.Y.Y_val[i] = Y[i];
			product_1_arg.a=a;
		}
		result_3 = product_1(&product_1_arg, clnt);
		temp = (float *) malloc(n*sizeof(float));
			for(int i=0;i<n;i++)
				temp[i]  =  result_3->prod.prod_val[i];
		
		if (result_3 == (aY *) NULL) {
			clnt_perror (clnt, "call failed");
		}
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int main (int argc, char *argv[])
{
	char *host;
	int sockfd, newsockfd, portnum, cllen;
	int children =0;
	struct sockaddr_in serverAddr, cli_addr;
	pid_t procID;
	if (argc < 3) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	
	
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0) {
		printf("[-]ERROR in connection.\n");
		exit(1);
	}
	//printf("[+]Client Socket created successfully.\n");

	bzero((char *) &serverAddr, sizeof(serverAddr));
	portnum = atoi(argv[2]);
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_port = htons(portnum);
	serverAddr.sin_addr.s_addr = INADDR_ANY;
	// Establishing connection to the server.
	
	if (bind(sockfd, (struct sockaddr *) &serverAddr, sizeof(serverAddr))<0){
		printf("[-]ERROR in binding.\n");
		exit(1);
	}
	listen(sockfd,5);
	printf("[+]Connected to Server.\n");
	
	for (;;){
	printf("Waiting for connection...\n");
	cllen = sizeof(cli_addr);
	newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &cllen);
	if(newsockfd <0){
		printf("[-]ERROR in accepting.\n");
		exit(1);
	}
	
	if(fork() == 0){
		close(sockfd);
		printf("[+]Connected.\n");
		do {
		// Make host the first argument passed by the client.
			host = argv[1];
		// Receive the choice of the client.
		recv(newsockfd, &choice, sizeof(int), 0);
			if (choice == 1){
				// Will receive the data that is needed and send the outcome.
				recv(newsockfd, &n, sizeof(int), 0);
				Y = (int *)malloc(n*sizeof(int));
				recv(newsockfd, Y, n*sizeof(int), 0);
				concurrent_ser_prog_1(host);
				send(newsockfd,result_1, sizeof(float), 0);
			}
			else if (choice == 2){
				recv(newsockfd, &n, sizeof(int), 0);
				Y = (int *)malloc(n*sizeof(int));
				recv(newsockfd, Y, n*sizeof(int), 0);
				concurrent_ser_prog_1(host);
				send(newsockfd,result_2, 2*sizeof(float), 0);
			}
			else if (choice == 3){
				recv(newsockfd, &n, sizeof(int), 0);
				Y = (int *)malloc(n*sizeof(int));
				recv(newsockfd, Y, n*sizeof(int), 0);
				recv(newsockfd, &a, sizeof(float), 0);
				concurrent_ser_prog_1(host);
				send(newsockfd, temp, n*sizeof(float), 0);
			}
		} while(1);
		exit (0);
	}
	close(newsockfd);
	children++;
	while (children){
		// WNOHANG tells pid to return immediately and not wait
		procID = waitpid((pid_t)-1, NULL,WNOHANG);
		if (procID<0){
			printf("Error in waitpid.\n");
		}else if (procID==0){
			break;
		}else {
			printf("\n");
		}
	}
	}
	return 0;
}
